# It is a supply chain model with two retailers, two distributors and one manufacturer. Customer arrival/demand is a Poisson process.
import simpy
import numpy as np
import random
#import sys,os
class SC_node:
    def __init__(self,env,name,P=0,p=None,suppliers=None,costs=None,delivery_times=None,S=None,s=None,H=None,purchase_lim=None):
        self.env = env
        self.name = name # node name
        self.P = P # profit generated by me per item sold
        self.p = p # probability distribution (suppliers)
        self.suppliers = suppliers # a list of suppliers available
        self.costs = costs # associated delivery costs per distributor
        self.delivery_times = delivery_times # associated delivery time per distributor
        self.S = S # my inventory parameter S (capacity)
        self.s = s # my inventory parameter S (threshold)
        self.H = H # my inventory holding cost
        if(self.S != None):
            #self.inventory = simpy.Container(self.env,capacity=S,init=S) # my inventory
            self.inventory = MonitoredContainer(enable_monitoring=True, env=env, init=S, capacity=S)
            # start the inventory monitor
            env.process(self.inventory_monitor(self.env))
        else:
            # if there is no inventory then it is customer or manufacturer
            self.inventory = None
        self.purchase_lim = purchase_lim # item purchase limits
        self.ordered = False
        # for recording stats
        self.inventory_levels = [] # record inventory level each day
        self.inventory_holding_cost = [] # record inventory holding cost each day
        self.delivery_cost = []
        self.total_item_sold = 0 # the total profit generated by the sales
        self.customer_returned = 0
        self.customer_arrived = 0
        if(suppliers!=None):
            self.orders_counts = np.zeros((len(suppliers),2)) # keeps count of units ordered from different suppliers
            # element at index 0 refers to D1, ele at 1 refers to D2, so on ...
            # we save [number of total units ordered, number of total orders made]
        else:
            self.orders_counts = np.zeros((1,2))
    # continuously monitor inventory levels (everyday)
    # if level is below threshold, then call to bulk_buy()
    def inventory_monitor(self,env):
        while True:
            yield self.env.timeout(1) # wait till end of the day
            # record inventory levels
            self.inventory_levels.append(self.inventory.level)
            #print(f"({self.name}) Inventory level = {self.inventory.level} at {self.env.now}")
            self.inventory_holding_cost.append(self.inventory.level*self.H)
            # check inventory levels
            if(self.inventory.level<self.s and not self.ordered):
                self.env.process(self.order(self.env))
                self.ordered = True
            if(self.inventory.get_queue and not self.ordered):
                # there are consumeres waiting in the queue for stocks
                # sometimes this situation will arise when inventory levels > s, but it does not
                # have sufficient units to fullfil incoming request
                #print(f"there are pending requestes to {self.name}")
                if(self.inventory.level!=self.inventory.capacity):
                    self.env.process(self.order(self.env))
                    self.ordered = True
    # this function is called when the inventory levels are below threshold s
    def order(self,env):
        # check if multiple suppliers are connected
        if(len(self.suppliers)>1):
            # select a supplier with probability p
            dist_idx = np.random.choice(len(self.suppliers),p=self.p)
        else:
            dist_idx = 0
        supplier = self.suppliers[dist_idx] # the supplier object
        C = 0
        D = 0
        if(self.costs!=None):
            C = self.costs[dist_idx] # associated cost
        if(self.delivery_times!=None):
            D = self.delivery_times[dist_idx] # associated delivery delay
        if(self.inventory!=None):
            # calculate number of units to order
            num_items_to_order = self.inventory.capacity - self.inventory.level
        else:
            # decide number of units to buy
            num_items_to_order = np.random.randint(self.purchase_lim[0],self.purchase_lim[1])
        # get items from the supplier
        supplier.customer_arrived += 1
        #print(f"{self.name}: ordering {num_items_to_order} from {supplier.name} at {self.env.now}")
        if(supplier.inventory!=None):
            if(self.inventory==None):
                if(supplier.inventory.level >= num_items_to_order):
                    supplier.inventory.get(num_items_to_order)
                    supplier.total_item_sold += num_items_to_order
                else:
                    supplier.customer_returned += 1
            else:
                supplier.total_item_sold += num_items_to_order
                yield supplier.inventory.get(num_items_to_order)
        # record stats, which distributor? how many units?
        self.orders_counts[dist_idx,0] += num_items_to_order
        self.orders_counts[dist_idx,1] += 1
        # record delivery cost
        self.delivery_cost.append(C)
        # wait for delivery!
        yield env.timeout(D)
        # get delivery of items, refill inventory
        #print(f"{self.name}: got {num_items_to_order} from {supplier.name} at {self.env.now}")
        if(self.inventory!=None):
            self.inventory.put(num_items_to_order)
        self.ordered = False

class MonitoredContainer(simpy.Container):
    def __init__(self, enable_monitoring, *args, **kwargs):
        self.enable_monitoring = enable_monitoring
        super().__init__(*args, **kwargs)
        self.leveldata = []
        self.timedata = []

        self.avg_level=0 # time-avergaed inventory level
        self.last_level=super().capacity
        self.last_timestamp=0

    # called whenever the level changes, to record the current level
    def record_level(self):
        # update the time-averaged inventory level
        delta_t = self._env.now-self.last_timestamp
        if delta_t >0:
            self.avg_level = ((self.avg_level*self.last_timestamp) + (delta_t*self.last_level))/float(self._env.now)
        # record the current level
        self.last_timestamp=self._env.now
        self.last_level = self._level
        if self.enable_monitoring:
            self.leveldata.append(self._level)
            self.timedata.append(self._env.now)
    def _do_put(self, *args, **kwargs):
        r = super()._do_put(*args, **kwargs)
        self.record_level()
        return r
    def _do_get(self, *args, **kwargs):
        r = super()._do_get(*args, **kwargs)
        self.record_level()
        return r

# this function implements the arrival of the customers. Function parameters are;
# env (simpy enviornment)
# lam (arrival rate lambda)
# p (probability distribution for retailers)
# returned_customers (customers who returned without getting the product)
# retailers (a list of retailers a customer can buy from)
def arrivals(env,lam,p,retailers):
    customer_number = 0
    while True:
        customer_number += 1
        # create a customer
        customer_i = SC_node(env,"customer_"+str(customer_number),suppliers=retailers,p = p,purchase_lim=[1,10])
        # customer buys items
        env.process(customer_i.order(env))
        t = random.expovariate(lambd=lam)
        yield env.timeout(t)
        del customer_i

# this function performs a single simulation run of the supply chain system, function parameters are
# lam (Î» arrival rate of customers)
# D (a list of distributors. Each element in the list is a dict)
# R  (a list of retailers. Each element in the list is a dict)
# p (probability distribution for reatilers)
# profit (profit P Rupee per item sold)
# NUM_OF_DAYS (simulation runs for NUM_OF_DAYS days)
def single_sim_run(lam, D_list, R_list, p=0.5, NUM_OF_DAYS=1000, P=100):#, print_log=False, print_stats=False):
    #if(not D_list or not R_list):
    #    print("Please add distributor(s)/retailers(s)")
    #    exit()
    if(len(p)!=len(R_list)):
        #print("Please check probability distribution for retailers! Assuming uniform distribution.")
        p = None
    #old_stdout = sys.stdout
    #if(not print_log):
        #sys.stdout = open(os.devnull, 'w')
    env = simpy.Environment()
    # create a manufacturer
    M = SC_node(env,"M")
    D = [] # list to store all Distributor objects
    # create Distributor object for each distributor in the D_list
    for d in D_list:
        D.append(SC_node(env,
                        d['name'],
                        S=d['S'],
                        s=d['s'],
                        H=d['H'],
                        suppliers=[M],
                        costs = d['C'],
                        delivery_times = d['D']))
    R = [] # list to store all Distributor objects
    # create Retailer object for each distributor in the D_list
    for r in R_list:
        R.append(SC_node(env,r['name'],
                               p = r['p'],
                               S=r['S'],
                               s=r['s'],
                               H=r['H'],
                               P=P,
                               suppliers = D,
                               costs = r['C'],
                               delivery_times = r['D']))
    env.process(arrivals(env,lam,p,retailers=R))
    env.run(NUM_OF_DAYS)
    #if(print_stats):
    #    sys.stdout = old_stdout
    #else:
    #    sys.stdout = open(os.devnull, 'w')
    avg_profit_per_day = 0
    avg_hold_cost_per_day = 0
    avg_del_cost_per_day = 0
    tot_customer_returned = 0
    tot_customer_arrived = 0
    timed_avg_num_items_in_inventory = 0
    #print(f"Num of customers returned = {sum(returned_customers)}")
    nodewise_stats_ls = []
    for nodes in R,D:
        for R_i in nodes:
            #print(f"**** {R_i.name} ****")
            #print(f"Total profit: {R_i.total_item_sold*R_i.P}, avg profit per day: {R_i.total_item_sold*R_i.P/NUM_OF_DAYS:.2f}")
            #print(f"Average Inventory Holding Cost: {sum(R_i.inventory_holding_cost)/NUM_OF_DAYS:.2f}")
            #for i in range(len(R_i.orders_counts)):
                #print(F"\tTotal units ordered from {R_i.suppliers[i].name}: {R_i.orders_counts[i,0]}, in {R_i.orders_counts[i,1]} deliveries.")
            #print(f"Total delivery cost: {sum(R_i.delivery_cost)}, avg delivery cost: {sum(R_i.delivery_cost)/NUM_OF_DAYS:.2f}")
            #print(f"timed avg num of items in inventory: {R_i.inventory.avg_level:.2f}")
            #print(f"frac of customers returned: {R_i.customer_returned*100/R_i.customer_arrived:.2f}%")
            #print(f"net profit:{(R_i.total_item_sold*R_i.P-sum(R_i.inventory_holding_cost)-sum(R_i.delivery_cost))/NUM_OF_DAYS}")
            #print("\n")
            avg_profit_per_day += R_i.total_item_sold*R_i.P/NUM_OF_DAYS
            avg_hold_cost_per_day += sum(R_i.inventory_holding_cost)/NUM_OF_DAYS
            avg_del_cost_per_day += sum(R_i.delivery_cost)/NUM_OF_DAYS
            tot_customer_returned += R_i.customer_returned
            tot_customer_arrived += R_i.customer_arrived
            timed_avg_num_items_in_inventory += R_i.inventory.avg_level
            nodewise_stats_ls.append([R_i.name,
                                      R_i.total_item_sold*R_i.P/NUM_OF_DAYS, #avg profit at R_i
                                      sum(R_i.inventory_holding_cost)/NUM_OF_DAYS, # avg holding cost
                                      sum(R_i.delivery_cost)/NUM_OF_DAYS, # avg del cost
                                      R_i.inventory.avg_level, # timed avg num of items in inventory
                                      R_i.total_item_sold/NUM_OF_DAYS, #throughput
                                      R_i.customer_returned/R_i.customer_arrived, # frac of customers returned empty handed
                                      (R_i.total_item_sold*R_i.P-sum(R_i.inventory_holding_cost)-sum(R_i.delivery_cost))/NUM_OF_DAYS])
    #print(f"*** Supply Chain ***")
    #print(f"Average profit generated by supply chain (per day)= {avg_profit_per_day:.2f}")
    #print(f"Average inventory hold cost of supply chain (per day)= {avg_hold_cost_per_day:.2f}")
    #print(f"Average delivery cost of supply chain (per day)= {avg_del_cost_per_day:.2f}")
    timed_avg_num_items_in_inventory = timed_avg_num_items_in_inventory/(len(R)+len(D))
    #print(f"Average Timed-avg number of items in inventory = {timed_avg_num_items_in_inventory}")
    avg_net_profit_per_day = avg_profit_per_day - (avg_hold_cost_per_day + avg_del_cost_per_day)
    #print(f"Net profit generated by supply chain = {avg_net_profit_per_day:.2f}")
    frac_customers_returned = tot_customer_returned*100/tot_customer_arrived
    #print(f"Fraction number of customers returned = {frac_customers_returned:.2f}%")
    #sys.stdout = old_stdout
    return frac_customers_returned, avg_profit_per_day, avg_hold_cost_per_day, avg_del_cost_per_day, timed_avg_num_items_in_inventory, avg_net_profit_per_day, nodewise_stats_ls
